## Цель

С нуля зафиксировать исходные вводные и собрать требования: доменная модель, пользовательские сценарии, страницы и маршруты, API, схема БД (Supabase), индексация/фоновые задачи.

## 1) Видение и ценность
- Какую ключевую ценность даём пользователю? Кто основные персоны (роли)?

Мы даем возможность пользователям финансово поучаствовать в формировании рейтинга небезразличных пользователю персон, объектов, брендов и других сущностей. Пользователи тянут рейтинг в разные стороны, покупая или продавая "стороны". При этом стороны не всегда имеют смысл плохо/хорошо, иногда это просто какая-то "спорная" классификация. Т.е. получается финансовое участие в перманентных спорах (которые нельзя разрешить ибо они являются не фактами, а мнениями). Монетизация мнений. При этом сама механика LS-LMSR позволяет устранить атаку сивиллы, поскольку цены на стороны являются path-invariant, т.е. не важно кто и какими долями покупал сторноны, главное что получилось в итоге. Т.е. исчезает целый слой манипуляций. Мы выносим на суд участников типичные "холиварные" вопросы, которые обычно провоцируют жаркие полемики в чатах и на форумах, однако здесь спорщики могут не только словами, но и делами (деньгами) подкрепить свою точку зрения. При этом они могут менять ее со временем, и это является нормальным в мире мнений. Более того, во-время измененная точка зрения, может также принести прибыль, если спорщик первым из толпы понимает куда меняется конъюнктура. 

- На каком минимальном сценарии можно проверить гипотезу (MVP)?

Не смотря на то, что спорить в принципе можно по любому поводу, первой предметной областью, которая будет отражена на сайте будут крипто-инфлюэнсеры. Это горячий топик и по гипотезе - "самовирусный" способ раскрутить сам проект. Благодаря свойствам LS-LMSR накрутить собственный рейтинг инфлюэнсеру достаточно сложно, при нечестной (обладающей непропорциональным капиталом) накрутке в одну сторону, противоположная сторона становится дешевле и тянуть в обратную сторону можно гораздо меньшими усилиями. Т.е. честный Давид может победить нечестного Голиафа.
Для каждого инфлюэнсера мы заводем два рынка (две оси)

1. Normie - Degen (принадлежность к субкультуре - mindset)
2. Alpha - Shitposting (эффективность советов - post-quality)

В MVP создавать рынки может только администратор платформы.
Мы выходим на одном из горячих блокчейнов - Base.
Для авторизации и охвата аудитории используем Privy кошельки (логин почтой, иксом (твиттером) и другим кошельком)

В качестве монет для покупки мы используем ETH.


## 2) Пользовательские сценарии (MVP → расширения)
- Список 3–7 базовых сценариев (кратко, шаги/ожидаемый результат)

Администратор может добавлять, редактировать, публиковать, скрывать и архивировать рынки. 

- Какие сценарии публичные (без логина)? Какие требуют авторизации?

## 3) Доменная модель (понятия и связи)
- Перечень сущностей (название, краткое описание)

Мы используем принцип для каждой цели голосования будут свои сущности и таблицы. Например для крипто-инфлюэнсеров будет своя сущность, для брэндов своя. Это похоже на наследование с дискриминатором, дело в том, что для каждой из таких сущностей будет разрабатываться отдельная навигация, роуты, компоненты. Например, сейчас важнейшей сущностю является крипто-инфлюэнсер. 

Более низкоуровневой сущностью является Класс Рынка. Для простоты в MVP у нас будут бинарные LS-LMSR рынки (т.е. рынки которые поддерживают только две опции, которые позиционируются как противоположные полюса одной шкалы). Класс Бинарного LS-LMSR рынка задается коэффициентом альфа (математика будет в отдельном md) и двумя опциями. Опции имеют slug, display_name, description.

А сам класс-рынка - также slug, display_name, description. В каком-то смысле класс рынка - это описания свойства объекта (например post-quality: Alpha/Shitposting, mindset: Normie/Degen)

Важными сущностями являются инстансы рынков, они привязываются к конкретным сущностям, за которые идет голосование. Т.е. если к сущности подключено два инстанса рынка, то она получается как бы в двухмерном пространстве. Также инстанс рынка отображается onchain -  именно там мы храним информацию по опциям (купленным пользователями). 

Сущностями также являются пользователи. Пользователи создаются через Privy имеют адреса и балансы (у пользователя должен быть один кошелек с системе).
Пользователи могут пополнять баланс эфиром (стандартный функционал Privy)
Выводить эфир.
А также покупать и продавать опции в рынках.

Это всё приводит к событиям, которые фиксируются в блокчейне, а также поступают через индексер в supabase.

- Связи между сущностями (1:N, M:N)

У каждого крипто-инфлюэнсера мы делаем по два инстанса рынков.
По инстансу рынка можно определить к какому инфлюэнсеру он прикреплен
У каждого пользователя есть баланс, а также купленные опции разных рынков.
Покупая или продавая доли пользователь может написать сообщение, сообщение может быть ответом на другое сообщение пользователя (это как треды на имиджбордах получается)

- Состояния/жизненный цикл ключевых сущностей

- Админимстратор создает инфлюэнсеров сначала в скрытом состоянии
Потом публикует их.
- Классы рынков заранее прописаны в базе, их не надо администрировать через UI
- инфлюэнсер может быть скрыт тогда его видит и может работать только администратор, открыт - тогда все могут, всё делать, и может быть exit-only можно только продавать доли, 
- Пользователь может зарегистрироваться (создасться)


## 4) Данные и БД (Supabase)
- Таблицы и поля (черновик, без деталей — просто чтобы видеть контуры)
- Какие данные публичные (RLS: SELECT)? Какие приватные/чувствительные?
- Какие индексы/уникальные ключи критически важны с самого начала?
- Какие VIEW/материализованные представления понадобятся?

## 5) API
- Внешние/внутренние эндпоинты (Next.js `app/api/v1/*`)
- Форматы запросов/ответов, пагинация, лимиты
- Какие операции сразу идут через сервер (service role)? Что оставляем публичному anon ключу под RLS?

## 6) Страницы и маршруты (пока гипотезы)
- Список страниц (URL → назначение, SEO‑заметки)
- Где нужен SSR с «всегда свежим» HTML? Где можно ISR и на сколько?

## 7) Индексация и фоновые задачи
- Какие события/логика требуют индексатора (`apps/r8-indexer`)?
- Триггеры, расписания, ретраи, дедупликация

## 8) Миграции и окружения
- Как будем оформлять миграции схемы (SQL/программные)?
- Окружения: dev → preview → prod; секреты Vercel/Supabase

## 9) Наблюдаемость и качество
- Логи, метрики, алерты, трассировки
- Ошибки фронта/сервера, перфоманс‑бюджет

## 10) Риски/ограничения
- Правовые/compliance, стоимость, масштабирование
- Блокеры/внешние зависимости

---

Заполни пункты тезисно. Я на основе ответов подготовлю черновики: схему БД (SQL для Supabase), список API, каркас страниц и RLS‑политики. 


